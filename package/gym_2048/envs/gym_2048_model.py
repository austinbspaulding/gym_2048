#!/bin/python3

import copy
from enum import IntEnum
import random
from typing import List
import math
import numpy as np
import numpy.typing as npt


class Gym2048DIRECTIONS(IntEnum):
    UP = 0
    RIGHT = 1
    DOWN = 2
    LEFT = 3

class Gym2048State:
    """A layout of 16 cells with numbered tiles"""

    _state: npt.NDArray[np.int16]
    _rand: random.Random

    def __init__(self, seed=None):
        self._state = np.zeros(16, np.int16)
        self._rand = random.Random()
        if (seed != None):
            self._rand.seed(seed)
        else:
            random.seed()
        self.spawn_random()

    @property
    def observation(self):
        return self._state
    
    @observation.setter
    def observation(self, observation):
        self._state = observation

    def spawn_random(self):
        """picks a random empty cell and assigns it either a 2 or a 4"""

        empties = []
        for i, val in enumerate(self._state):
            if val == 0:
                empties.append(i)

        self._state[self._rand.choice(empties)] = self._rand.choice([2, 2, 2, 4])

    def _reverse_orders(self, order: List[List[int]]):
        for o in order:
            o.reverse()
        return order

    def _left_order(self):
        return [
            [0, 1, 2, 3],
            [4, 5, 6, 7],
            [8, 9, 10, 11],
            [12, 13, 14, 15],
        ]
    
    def _up_order(self):
        return [
            [0, 4, 8, 12],
            [1, 5, 9, 13],
            [2, 6, 10, 14],
            [3, 7, 11, 15]
        ]
        
    def _right_order(self):
        return self._reverse_orders(self._left_order())
    
    def _down_order(self):
        return self._reverse_orders(self._up_order())
    
    def _groups(self, direction: Gym2048DIRECTIONS):
        """generates groups of indices that represent cells that may interact
         during a move in the given direction. these increment against the movement
        """

        rows = 4
        cols = 4

        groups: List[List[int]] = []
        if direction in [Gym2048DIRECTIONS.UP, Gym2048DIRECTIONS.DOWN]:
            for i in range(cols):
                group = []                    
                for j in range(rows):
                    group.append(rows * j + i)
                groups.append(group)

        else:
            for i in range(rows):
                group = []
                for j in range(cols):
                    group.append(j + cols * i)
                groups.append(group)

        if direction in [Gym2048DIRECTIONS.DOWN, Gym2048DIRECTIONS.RIGHT]:
            groups.reverse()
            for group in groups:
                group.reverse()

        return groups
    
    def _interactions(self, groups):
        """generates tuples in the order that interactions should occur while
        moving in the given direction.

        groups is generated by Gym2048State._groups()

        returns tuples in the form (from, into) where "from" is the index of
        the cell that is cascading into the cell at index "into"
        """

        for group in groups:
            for i in range(1, len(group)):
                while i > 0:
                    yield(group[i], group[i - 1])
                    i -= 1

        # rows = 4
        # cols = 4
        # start_index: int
        # inc_group_head: int
        # inc_group_member: int
        # group_count: int
        # group_size: int
        # match(direction):
        #     case(Gym2048DIRECTIONS.UP):
        #         start_index = 0
        #         inc_group_head = 1
        #         inc_group_member = rows
        #         group_count = cols
        #         group_size = rows
        #     case(Gym2048DIRECTIONS.DOWN):
        #         start_index = rows * cols - 1
        #         inc_group_head = -1
        #         inc_group_member = -1 * rows
        #         group_count = cols
        #         group_size = rows
        #     case(Gym2048DIRECTIONS.LEFT):
        #         start_index = 0
        #         inc_group_head = cols
        #         inc_group_member = 1
        #         group_count = rows
        #         group_size = cols
        #     case(Gym2048DIRECTIONS.RIGHT):
        #         start_index = 15
        #         inc_group_head = -1 * cols
        #         inc_group_member = -1
        #         group_count = rows
        #         group_size = cols
        
        # head = start_index
        # curr = start_index
        # for _ in range(group_count):
        #     for i in range(group_size):
        #         for j in range(i):
        #             yield (curr - , curr - )
                
        #     head = head + inc_group_head
        #     curr = head


        
    
    def _move_1(self, order: List[int], index: int):
        if index < 1 or index > 3:
            raise(Exception(f"bad index given to move 1: {index}"))
        
        from_i = order[index]
        to_i = order[index - 1]
        
        if self._state[from_i] != 0:
            # if the to cell is empty, swap cells
            if self._state[to_i] == 0:
                self._state[to_i] = self._state[from_i]
                self._state[from_i] = 0
            # if the to cell matches the from cell, merge
            elif self._state[to_i] == self._state[from_i]:
                created = self._state[to_i] * 2
                self._state[to_i] = created
                self._state[from_i] = 0

    def _get_order(self, direction: Gym2048DIRECTIONS):
        match(direction):
            case(Gym2048DIRECTIONS.UP):
                return self._up_order()
            case(Gym2048DIRECTIONS.DOWN):
                return self._down_order()
            case(Gym2048DIRECTIONS.LEFT):
                return self._left_order()
            case(Gym2048DIRECTIONS.RIGHT):
                return self._right_order()

    def simulate_move(self, direction: Gym2048DIRECTIONS):
        already_merged = []
        for f, i in self._interactions(self._groups(direction)):
            if f in already_merged or i in already_merged:
                continue
            fv = self._state[f]
            if fv == 0:
                continue
            iv = self._state[i]
            if iv == 0:
                self._state[i] = fv
                self._state[f] = 0
                continue
            if fv == iv:
                self._state[i] = iv * 2
                self._state[f] = 0
                already_merged.append(i)
        # order = self._get_order(direction)
        
        # for o in order:
        #     #o[0] is already at the edge
        #     for i in range(1, 4):
        #         self._move_1(o, i)
        #     for i in range(1, 3):
        #         self._move_1(o, i)
        #     self._move_1(o, 1)

    def move(self, direction: Gym2048DIRECTIONS):
        self.simulate_move(direction)
        self.spawn_random()

    def _top_two(self, i: int):
        if i == 0:
            return "  "
        return f"{math.floor(i / 100):0>2}"
    
    def _bottom_two(self, i: int):
        if i == 0:
            return "  "
        return f"{i % 100:0>2}"

    def __str__(self) -> str:
        out = ""
        header = "╔════╦════╦════╦════╗\n"
        for i in range(4):
            out += header
            header = "╠════╬════╬════╬════╣\n"
            for f in [self._top_two, self._bottom_two]:
                for x in range(4):
                    out += f"║ {f(self._state[i * 4 + x])} "
                out += "║\n"
        out += "╚════╩════╩════╩════╝"
        return out


class Gym2048Model:

    @staticmethod
    def ACTIONS(state: Gym2048State):
        def viable_move(d: Gym2048DIRECTIONS, state: Gym2048State):
            for g in state._groups(d):
                vals = list(map(lambda x : state._state[x], g))
                if 0 in vals and vals.index(0) < len(vals) - 1:
                    return True
                for i in range(len(vals) - 1):
                    if vals[i] == vals[i + 1]:
                        return True
            return False

        out: List[int] = []
        for d in Gym2048DIRECTIONS:
            if viable_move(d, state):
                out.append(d)
        return out

    @staticmethod
    def RESULT(state: Gym2048State, action) -> Gym2048State:
        state1 = copy.deepcopy(state)
        state1.simulate_move(action)
        return state1

    @staticmethod
    def GOAL_TEST(state: Gym2048State):
        if 2048 in state._state:
            return True
        if len(Gym2048Model.ACTIONS(state)) == 0:
            return True
        return False

    @staticmethod
    def STEP_COST(state: Gym2048State, action, state1: Gym2048State):
        """returns the bonus score accrued by merging tiles"""
        return Gym2048Model.HEURISTIC(state1) - Gym2048Model.HEURISTIC(state)

    @staticmethod
    def HEURISTIC(state: Gym2048State):
        if 2048 in state.observation:
            return 5000
        return sum(state.observation)


if(__name__ == "__main__"):
    state = Gym2048State()
    for _ in range(7):
        state.spawn_random()
    print("8 random spawns:")
    print(state)

    state.move(Gym2048DIRECTIONS.LEFT)
    print("after moving left:")
    print(state)

    state.move(Gym2048DIRECTIONS.UP)
    print("after moving up:")
    print(state)

    state.move(Gym2048DIRECTIONS.RIGHT)
    print("after moving right:")
    print(state)

    state.move(Gym2048DIRECTIONS.DOWN)
    print("after moving down:")
    print(state)

    for i in Gym2048DIRECTIONS:
        for c in range(len(state._state)):
            state._state[c] = 2
        state.move(i)
        print("after moving:", i)
        print(state)
        state.move(i)
        print("after moving:", i)
        print(state)


    